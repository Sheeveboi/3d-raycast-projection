<html>
    <canvas>
    </canvas>
    <body>
        <input type="range" value=75 id="persp">
        <script>
        "use strict";
        try {
            var canvas = document.querySelector("canvas");
            var c = canvas.getContext("2d");

            canvas.width = 500;
            canvas.height = 500;
            
            var center = [canvas.width/2,canvas.height/2];

            function Node(x,y,z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            function Mesh(nodes,name,x,y,z) {
                this.nodes = nodes;
                this.name = name;
                this.x = x;
                this.y = y * -1;
                this.z = z;

                this.drawNodes = function() {
                    for (var i = 0; i < this.nodes.length; i++) {
                        
//let vector[x,y,z] be the amount of displacement relative to the node to position of camera
//let node[x,y,z] be the camera relative cordinates of each node 
//let camera[x,y,z] = [0,0,0] as this defines camera relative space instead of real space
//let real space be an offset value matrix for camera relative space 
//let the perspective scalar set how far away the plane each ray is coliding with is away from the camera point
                        
//essentially, coordinates will shift around the camera instead of the camera coordinates shifting around. this creates camera relative space and real space where real space is an offeset to camera space
                       
//define parametric equasion for the ray [x,y,z,x1,y1,z1] f(t) = [x + t(x1 - x),y + t(y1 - y),z + t(z1 - 1)] 
//let x,y,z = node[x,y,z]
//let x1,y1,z1 = camera[x,y,z]
                        
//let the camera plane normal (n) vector coordinates in camera relative space = [0,0,perspective]
//let the test vector (w) = [0,0,perspective] + [x,y,z]
                        
                        
                        
//find t in f(t) with equasion -(w[0] * n[0] + w[1] * n[1] + w[2] * n[2]) / (n[0] * p(0)[0] + n[1] * p(0)[1] + n[0] * p(0)[2])
//plug output of equasion into f(t) to get x,y cordinates
//offset coridinates to fit canvas 
                       
                        
                        function ray(x,y,z,x1,y1,z1,t,set) {
                            switch (set) {
                                case 0: 
                                    return x + t*(x1 - x);
                                    break;
                                case 1:
                                    return y + t*(y1 - y);
                                    break;
                                case 2:
                                    return z + t*(z1 - z);
                                    break;
                            }
                        }
                        
                        var perspective = JSON.parse(document.getElementById("persp").value);
                        
                        var rayVector = [];
                        rayVector[0] = this.x + this.nodes[i].x;
                        rayVector[1] = this.y + this.nodes[i].y;
                        rayVector[2] = this.z + this.nodes[i].z;
                        
                        //c.fillRect(rayVector[0]+250,rayVector[3]+250,5,5);
                        
                        var cameraNormal = [];
                        cameraNormal[0] = 0;
                        cameraNormal[1] = 0;
                        cameraNormal[2] = perspective;
                        
                        var testVector = [];
                        testVector[0] = cameraNormal[0] - rayVector[0];
                        testVector[1] = cameraNormal[1] - rayVector[1];
                        testVector[2] = cameraNormal[2] - rayVector[2];
                        
                        var t = -(testVector[0] * cameraNormal[0] + testVector[1] * cameraNormal[1] + testVector[2] * cameraNormal[2]) / (cameraNormal[0] * ray(rayVector[0],rayVector[1],rayVector[2],0,0,0,0,0) + cameraNormal[1] * ray(rayVector[0],rayVector[1],rayVector[2],0,0,0,0,1) + cameraNormal[2] * ray(rayVector[0],rayVector[1],rayVector[2],0,0,0,0,2));
                        
                        this.screenX = ray(rayVector[0],rayVector[1],rayVector[2],0,0,0,t,0) + 250;
                        this.screenY = ray(rayVector[0],rayVector[1],rayVector[2],0,0,0,t,1) + 250;
                        
                        c.fillRect(this.screenX,this.screenY,5,5);
                        
                        c.fillText((this.screenX-250) + ", " + (this.screenY-250),20,(i+1)*15);
                    }
                    c.fillText(this.name,this.screenX+10,this.screenY-10);
                }
            }

            var globalMeshArr = [];

            function createMesh(gx,gy,gz,size,type,name) {
                
                var nodeMount = [];
                if (type == "cube") {
                    nodeMount.push(new Node(size,size,(size*-1)))
                    nodeMount.push(new Node((size*-1),size,(size*-1)));
                    nodeMount.push(new Node(size,(size*-1),(size*-1)));
                    nodeMount.push(new Node((size*-1),(size*-1),(size*-1)));
                    
                    nodeMount.push(new Node(size,size,size))
                    nodeMount.push(new Node((size*-1),size,size));
                    nodeMount.push(new Node(size,(size*-1),size));
                    nodeMount.push(new Node((size*-1),(size*-1),size));
                    
                }
                if (type == "line") {
                    nodeMount.push(new Node(gx,gy,0));
                    nodeMount.push(new Node(gx,gy,10));
                    nodeMount.push(new Node(gx,gy,20));
                    nodeMount.push(new Node(gx,gy,30));
                    nodeMount.push(new Node(gx,gy,40));
                }
                if (type == "point") {
                    nodeMount.push(new Node(gx,gy,gz));   
                }  
                if (name == undefined) {
                    globalMeshArr.push(new Mesh(nodeMount,"unnamed",gx,gy,gz));
                } else {
                    globalMeshArr.push(new Mesh(nodeMount,name,gx,gy,gz));
                }    
            }
                
            //createMesh((Math.random()*100)-50,(Math.random()*100)-50,Math.random()*50+20,10,"cube","Cube1");
            /*createMesh((Math.random()*100)-50,(Math.random()*100)-50,Math.random()*50+20,10,"cube","my bitch");
            createMesh((Math.random()*100)-50,(Math.random()*100)-50,Math.random()*50+20,10,"cube","my bitch");
            createMesh((Math.random()*100)-50,(Math.random()*100)-50,Math.random()*50+20,10,"cube","my bitch");*/
            createMesh(0,-5,10,5,"cube","point1");
            
            var j = 0;

            function animate() {
                requestAnimationFrame(animate); 
                c.clearRect(0,0,innerWidth,innerHeight);
                //document.querySelector("input").innerHTML = persp;
                j+=.02;
                for (var o = 0; o < globalMeshArr.length; o++) {
                    c.fillStyle = "black";
                    //globalMeshArr[o].z += Math.sin(j)*3;
                    //globalMeshArr[o].y += Math.sin(j)/3;
                    globalMeshArr[0].x += Math.cos(j)/3;
                    globalMeshArr[o].drawNodes();
                }
                /*c.fillStyle = "red";
                c.fillRect(center[0],center[1],5,5);
                c.beginPath();
                c.moveTo(250,0);
                c.lineTo(250,500);
                c.stroke();
                c.beginPath();
                c.moveTo(0,250);
                c.lineTo(500,250);
                c.stroke();*/
            }
            animate();
        }
        catch (err) {
            alert(err);   
        }
        alert("compiled");
        </script>
    </body>
</html>
